---
title: Search memories
description: Search the CEMS memory system using the enhanced retrieval pipeline
---

Search memories using CEMS's multi-stage retrieval pipeline with query understanding, HyDE, RRF fusion, and LLM re-ranking.

## Endpoint

```
POST /api/memory/search
```

**Authentication**: Required (Bearer token)

## Request body

<ParamField path="query" type="string" required>
  The search query. Maximum 2000 characters (automatically truncated).
</ParamField>

<ParamField path="limit" type="integer" default={10}>
  Maximum number of results to return
</ParamField>

<ParamField path="scope" type="string" default="both">
  Search scope:
  - `personal` - Only your personal memories
  - `shared` - Only team-shared memories
  - `both` - Search both scopes
</ParamField>

<ParamField path="max_tokens" type="integer" default={4000}>
  Token budget for assembled results. Results are selected greedily within this budget.
</ParamField>

<ParamField path="mode" type="string" default="vector">
  Retrieval mode:
  - `auto` - Smart routing based on query analysis
  - `vector` - Fast vector search (0 LLM calls)
  - `hybrid` - Full pipeline with HyDE + RRF + re-ranking (3-4 LLM calls)
</ParamField>

<ParamField path="enable_query_synthesis" type="boolean" default={false}>
  Enable LLM-powered query expansion into 2-5 search terms
</ParamField>

<ParamField path="enable_hyde" type="boolean" default={false}>
  Enable HyDE (Hypothetical Document Embeddings) for better semantic matching
</ParamField>

<ParamField path="enable_rerank" type="boolean" default={true}>
  Enable LLM re-ranking of results for improved relevance
</ParamField>

<ParamField path="enable_graph" type="boolean" default={true}>
  Enable graph traversal for related memories
</ParamField>

<ParamField path="project" type="string">
  Project identifier for scoped boost. Format: `org/repo`
  
  Memories with matching `source_ref` get a 1.3x score boost.
</ParamField>

<ParamField path="raw" type="boolean" default={false}>
  Debug mode: bypass filtering and return all candidates
</ParamField>

## Response

<ResponseField name="success" type="boolean">
  Whether the search succeeded
</ResponseField>

<ResponseField name="results" type="object[]">
  Array of search results
  
  <Expandable title="properties">
    <ResponseField name="memory_id" type="string">
      Unique identifier for this memory
    </ResponseField>
    
    <ResponseField name="content" type="string">
      Memory content
    </ResponseField>
    
    <ResponseField name="category" type="string">
      Memory category (preferences, decisions, patterns, etc.)
    </ResponseField>
    
    <ResponseField name="score" type="number">
      Relevance score (higher is better)
    </ResponseField>
    
    <ResponseField name="source_ref" type="string">
      Source reference (e.g., `project:org/repo`)
    </ResponseField>
    
    <ResponseField name="tags" type="string[]">
      Tags associated with this memory
    </ResponseField>
    
    <ResponseField name="timestamp" type="string">
      When the memory was created (ISO 8601)
    </ResponseField>
  </Expandable>
</ResponseField>

<ResponseField name="count" type="integer">
  Number of results returned
</ResponseField>

<ResponseField name="mode" type="string">
  Retrieval mode used (vector, hybrid, or unified)
</ResponseField>

<ResponseField name="tokens_used" type="integer">
  Total tokens in the assembled results
</ResponseField>

<ResponseField name="queries_used" type="string[]">
  Array of queries used in the search (shows query synthesis if enabled)
</ResponseField>

<ResponseField name="total_candidates" type="integer">
  Total candidates retrieved before filtering
</ResponseField>

<ResponseField name="filtered_count" type="integer">
  Number of candidates filtered out
</ResponseField>

<ResponseField name="intent" type="object">
  Query intent analysis (when available)
  
  <Expandable title="properties">
    <ResponseField name="primary_intent" type="string">
      Detected intent type (preference, temporal, factual, etc.)
    </ResponseField>
    
    <ResponseField name="complexity" type="string">
      Query complexity (simple, moderate, complex)
    </ResponseField>
  </Expandable>
</ResponseField>

## Examples

### Basic search

```bash
curl -X POST https://your-cems-server.com/api/memory/search \
  -H "Authorization: Bearer $CEMS_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "query": "What are my TypeScript preferences?",
    "limit": 5
  }'
```

**Response:**

```json
{
  "success": true,
  "results": [
    {
      "memory_id": "550e8400-e29b-41d4-a716-446655440000",
      "content": "I prefer using TypeScript for all new backend services",
      "category": "preferences",
      "score": 0.89,
      "tags": ["typescript", "backend"],
      "timestamp": "2024-02-28T10:30:00Z"
    }
  ],
  "count": 1,
  "mode": "vector",
  "tokens_used": 15,
  "queries_used": ["What are my TypeScript preferences?"],
  "total_candidates": 10,
  "filtered_count": 9
}
```

### Hybrid search with HyDE

```bash
curl -X POST https://your-cems-server.com/api/memory/search \
  -H "Authorization: Bearer $CEMS_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "query": "How do we handle authentication?",
    "mode": "hybrid",
    "enable_hyde": true,
    "enable_query_synthesis": true,
    "project": "acme/api-server"
  }'
```

This uses the full pipeline:
1. Query understanding and intent detection
2. Query synthesis (expands to 2-5 queries)
3. HyDE (generates hypothetical answer)
4. Multi-query retrieval
5. RRF fusion
6. LLM re-ranking
7. Project-scoped boost for `acme/api-server`

## Retrieval pipeline stages

The enhanced retrieval pipeline (`retrieve_for_inference`) implements 9 stages:

<Steps>
  <Step title="Query understanding">
    Analyzes intent, domains, and entities using an LLM
  </Step>
  
  <Step title="Query synthesis">
    LLM expands query into 2-5 search terms for better coverage
  </Step>
  
  <Step title="HyDE">
    Generates hypothetical ideal answer for better semantic matching
  </Step>
  
  <Step title="Candidate retrieval">
    Vector search + graph traversal across multiple queries
  </Step>
  
  <Step title="RRF fusion">
    Reciprocal Rank Fusion combines multi-query results
  </Step>
  
  <Step title="LLM re-ranking">
    Smarter relevance scoring using LLM judgment
  </Step>
  
  <Step title="Relevance filtering">
    Removes results below threshold
  </Step>
  
  <Step title="Unified scoring">
    Applies time decay, priority boost, and project-scoped scoring
  </Step>
  
  <Step title="Token-budgeted assembly">
    Greedy selection within token budget
  </Step>
</Steps>

See [Search Pipeline](/concepts/search-pipeline) for detailed explanations.

## Search modes comparison

| Mode | LLM Calls | Speed | Best for |
|------|-----------|-------|----------|
| `vector` | 0 | Fastest | Simple queries, known terms |
| `auto` | 0-4 | Smart | General use (default) |
| `hybrid` | 3-4 | Thorough | Complex queries, preferences, temporal |

## Error responses

**Status codes:**
- `400` - Bad request (missing query)
- `401` - Unauthorized (invalid or missing API key)
- `500` - Internal server error

## Implementation reference

See `src/cems/api/handlers/memory.py:272-386` for the complete implementation.
